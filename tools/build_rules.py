#!/usr/bin/env python3

import re
import os
import hashlib
import json
from glob import glob

CURDIR = os.path.dirname(os.path.realpath(__file__))
BUILDDIR = os.path.join(CURDIR, '..', 'build')
RULESDIR = os.path.join(CURDIR, '..', 'rules')
SOURCES_TEXT = ('backend.txt', 'frontend.txt', )
SOURCES_CUSTOM = 'custom.yar'
SOURCES_BURNER = 'burner-domains.txt'
RULENAME = 'all-confirmed'
WHITELISTDIR = os.path.join(CURDIR, '..', 'corpus', 'whitelisted')

yara_match_pattern = '\$ = (?:/(.+)/|"(.+)")\s*\n'


"""
Todo:

1. Group signatures together under same yara rule
"""

def find_file_hashes(root):
    allhashes = dict()
    for prefix, dirs, files in os.walk(root):
        for fn in files:
            fullpath = os.path.join(prefix, fn)

            # /malware/whitelisted/NeoPI/animal_shell_poc.php => NeoPI/animal_shell_poc.php
            relpath = fullpath[len(root) + 1:]

            with open(fullpath, 'rb') as fh:
                hash = hashlib.sha1(fh.read()).hexdigest()
                allhashes[hash] = relpath
    return allhashes


def sig_to_name(sig):
    # produce somewhat readable name from a signature

    # 
    try:  # py2
        h = hashlib.sha1(sig).hexdigest()[:8]
    except TypeError:  # py3
        h = hashlib.sha1(bytes(sig, 'utf-8')).hexdigest()[:8]
    ascii = re.sub(r'[^\w\d]+','_', sig).strip('_')

    if ascii:
        return 'r_' + ascii[:16].rstrip('_') + '_' + h
    else:
        return 'r_' + h

# def escape_string(s):
#     # py2/3 compatible
#     try:
#         new = s.encode('string_escape').replace(r"\'","'")
#     except LookupError:
#         new = s.encode('unicode_escape').decode('utf-8').replace(r"\'","'")
#     return new 


def sig_to_yara(sig):
    # convert literals or regex to yara rule

    if sig.stype == 'yara':
        return sig.definition # is already yara format

    if sig.stype == 'literal':
        # re.escape escapes too much, encode() escapes too little (no ")
        yaradef = '"' + re.sub(r'([\\"])', r'\\\1', sig.definition) + '"'
    elif sig.stype == 'regex':
        yaradef = '/' + sig.definition + '/'

    return "rule {} {{\n\tstrings: $ = {}\n\tcondition: any of them\n}}\n" \
        .format(sig.name, yaradef).lstrip()


def write_grep_sigs(sigs):

    lines = []

    for s in sigs:
        if s.stype == 'literal':
            lines.append(re.escape(s.definition).replace(r'\'', "'"))
        elif s.stype == 'regex':
            lines.append(s.definition)

    with open(os.path.join(BUILDDIR, RULENAME + '.txt'), 'w') as fh:
        for line in sorted(lines):
            fh.write(line + '\n')


def write_yara_sigs(sigs):

    lines = []
    for sig in sigs:
        lines.append(sig_to_yara(sig))

    with open(os.path.join(BUILDDIR, RULENAME + '.yar'), 'w') as fh:
        fh.write("/* AUTO GENERATED BY <{0}> DO NOT EDIT\n\nWHITELIST = {1}\n\n*/\n\n".format(
            __file__,
            json.dumps(find_file_hashes(WHITELISTDIR), indent=2, sort_keys=True)
        ))

        for line in lines:
            fh.write(line)


def collect_yara_signatures():
    # these are actually multiple signatures, but we dont
    # have to split them, we'll just append them later
    with open(os.path.join(RULESDIR, SOURCES_CUSTOM)) as fh:
        return [Signature('yara', fh.read())]


def collect_text_signatures():

    sigs = []

    for path in SOURCES_TEXT:
        with open(os.path.join(RULESDIR, path)) as fh:
            for line in fh:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue

                if line.startswith('/'):
                    line = line[1:-1]
                    stype = 'regex'
                else:
                    stype = 'literal'

                sigs.append(Signature(stype, line))
    
    return sigs


class Signature(object):

    def __init__(self, stype, definition, name=None):
        assert stype in ('literal', 'regex', 'yara')

        self.stype = stype
        self.definition = definition
        self.name = sig_to_name(definition)


def collect_burner_signatures():
    domains = set()
    with open(os.path.join(RULESDIR, SOURCES_BURNER)) as fh:
        for line in fh:
            line = line.strip()
            if not line or line.startswith('#'):
                continue

            domains.add(line)

    sigs = []

    transformations = (
        # 105,102,40,40,110,101,119,32,82,101,103,69,120,112,40,39,111,110,101,112,97,103,101
        lambda x: ','.join([str(ord(i)) for i in x]),

        # 105, 102, 40, 
        lambda x: ', '.join([str(ord(i)) for i in x]),
        
        # js-query.su/ 
        lambda x: '{}/'.format(x),

        # '\\x69\\x70\\x2E\\x35\\x75\\x75\\x38\\x2E\\x63\\x6F\\x6D'
        lambda x: ''.join([r'\x{}'.format(hex(ord(i))[2:].upper()) for i in x]),

        # \x69\x70\x2e\x35\x75\x75\x38\x2e\x63\x6f\x6d
        lambda x: ''.join([r'\x{}'.format(hex(ord(i))[2:].lower()) for i in x]),
        
        # &#99;&#108;&#111;&#117;&#100;&#102;&#117;&#115;&#105;&#111;&#110;&#46;&#109;&#101;
        lambda x: ''.join(['&#{};'.format(ord(i)) for i in x])

    )

    for f in transformations:
        sigs.extend([Signature('literal', f(x)) for x in domains])

    return sigs


def write_all_rules():

    """
    allsigs = [
        {
            'name: 'xyz_hash',
            'type': 'literal' | 'regex' | 'yara',
            'sig': 'xyz'
        }
    ]
    """
    allsigs = []
    allsigs += collect_text_signatures()
    allsigs += collect_burner_signatures()
    allsigs += collect_yara_signatures()

    # print(json.dumps(allsigs, indent=2))

    write_grep_sigs(allsigs)
    write_yara_sigs(allsigs)
    print("Written build files to {}".format(BUILDDIR))


if __name__ == '__main__':
    write_all_rules()
